package com.xiaoniu.finance.processor;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import com.xiaoniu.finance.annotation.router.Router;
import com.xiaoniu.finance.processor.utils.Logger;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.StringUtils;

import java.io.IOException;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;

import static com.xiaoniu.finance.processor.consts.Consts.KEY_MODULE_NAME;
import static com.xiaoniu.finance.processor.consts.Consts.KEY_PACKAGE_NAME;
import static com.xiaoniu.finance.processor.consts.RouterConst.ANNOTATION_TYPE_ROUTE;
import static com.xiaoniu.finance.processor.consts.RouterConst.IATRACK;
import static com.xiaoniu.finance.processor.consts.RouterConst.ROUTER_MANAGER;
import static com.xiaoniu.finance.processor.consts.RouterConst.ROUTER_MANAGER_METHOD;
import static com.xiaoniu.finance.processor.consts.RouterConst.ROUTER_MANAGER_PACKAGE;
import static com.xiaoniu.finance.processor.consts.RouterConst.XNACTIONCTRL;
import static com.xiaoniu.finance.processor.consts.RouterConst.XNROUTER;

@AutoService(Processor.class)
@SupportedOptions(KEY_MODULE_NAME)
@SupportedSourceVersion(SourceVersion.RELEASE_7)
@SupportedAnnotationTypes({ANNOTATION_TYPE_ROUTE})
public class XnRouterProcessor extends AbstractProcessor {
    private static final String WARNING_TIPS = "DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER.";
    private Map<String, Element> routers = new TreeMap<>();
    private Filer mFiler;       // File util, write class file into disk.
    private Logger logger;
    private Elements elementUtils;

    private String moduleName = null;   // Module name, maybe its 'app' or others
    private String mPackageName = null;   // Package name, maybe its 'app' or others

    private TypeMirror typeMirror = null;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);
        mFiler = processingEnvironment.getFiler();
        elementUtils = processingEnvironment.getElementUtils();
        logger = new Logger(processingEnv.getMessager());   // Package the log utils.

        // Attempt to get user configuration [moduleName]
        Map<String, String> options = processingEnv.getOptions();
        if (MapUtils.isNotEmpty(options)) {
            moduleName = options.get(KEY_MODULE_NAME);
            mPackageName = options.get(KEY_PACKAGE_NAME);
        }

        if (StringUtils.isNotEmpty(moduleName)) {
            moduleName = moduleName.replaceAll("[^0-9a-zA-Z_]+", "");
            logger.info("The user has configuration the module name, it was [" + moduleName + "]");
        } else {
            logger.error("These no module name, at 'build.gradle', like :\n" +
                    "apt {\n" +
                    "    arguments {\n" +
                    "        moduleName project.getName();\n" +
                    "    }\n" +
                    "}\n");
            throw new RuntimeException("ARouter::Compiler >>> No module name, for more information, look at gradle log.");
        }

        if (StringUtils.isNotEmpty(mPackageName)) {
            logger.info("The user has configuration the package name, it was [" + mPackageName + "]");
        } else {
            logger.error("These no module name, at 'build.gradle', like :\n" +
                    "apt {\n" +
                    "    arguments {\n" +
                    "        libPackageName project.getName();\n" +
                    "    }\n" +
                    "}\n");
            throw new RuntimeException("ARouter::Compiler >>> No module name, for more information, look at gradle log.");
        }

        typeMirror = elementUtils.getTypeElement(IATRACK).asType();
        logger.info(">>> RouteProcessor init. <<<");
    }


    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {
        if (CollectionUtils.isNotEmpty(annotations)) {
            Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(Router.class);
            try {
                parseRouters(elements);
            } catch (Exception e) {
                logger.error(e);
            }
            return true;
        }

        return false;
    }

    private void parseRouters(Set<? extends Element> elements) {
        if (CollectionUtils.isNotEmpty(elements)) {
            logger.info(">>> Found XnAbstractTrack, size is " + elements.size() + " <<<");
            //验证元素是否继承至XnAbstractTrack,然后缓存起来
            for (Element element : elements) {
                if (verify(element)) {  // Check the action meta
                    logger.info("A router verify over, its " + element.asType());
                    Router router = element.getAnnotation(Router.class);

                    Element lastPath = routers.get(router.value());
                    if (null != lastPath) { // Added, throw exceptions
                        throw new IllegalArgumentException(
                                String.format(Locale.getDefault(), "More than one routers use same path [%d], They are [%s] and [%s].",
                                        router.value(),
                                        lastPath.getSimpleName(),
                                        element.getSimpleName())
                        );
                    }

                    routers.put(router.value(), element);
                } else {
                    logger.error("A XnAbstractTrack verify failed, its " + element.asType());
                }
            }


            // Build method : 'setup'
            MethodSpec.Builder setupBuilder = MethodSpec.methodBuilder(ROUTER_MANAGER_METHOD)
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)//
                    .returns(void.class);//

            TypeElement xnRouter = elementUtils.getTypeElement(XNROUTER);
            TypeElement xnRouteMeta = elementUtils.getTypeElement(XNACTIONCTRL);
            // Generate
            if (null != routers && routers.size() > 0) {
                // Build method body
                for (Map.Entry<String, Element> entry : routers.entrySet()) {
                    Router router = entry.getValue().getAnnotation(Router.class);
                    String statment = "$T.getInstance().registerModule($S,new $T($S, $L, $L, $L, $L, new $T()));";
                    setupBuilder.addStatement(statment, xnRouter, router.value(), xnRouteMeta,
                            router.value(), router.enable(), router.permission(), router.crossable(), router.match(),
                            ClassName.get((TypeElement) entry.getValue()));
                }
            }

            // Write to disk(Write file even interceptors is empty.)
            try {
                JavaFile.builder(mPackageName + ROUTER_MANAGER_PACKAGE,
                        TypeSpec.classBuilder(StringUtils.capitalize(moduleName.toLowerCase(Locale.getDefault())) + ROUTER_MANAGER)
                                .addModifiers(Modifier.PUBLIC)
                                .addJavadoc(WARNING_TIPS)
                                .addMethod(setupBuilder.build())
                                .build()
                ).build().writeTo(mFiler);
            } catch (IOException e) {
                e.printStackTrace();
            }

            logger.info(">>> XnAbstractTrack group write over. <<<");
        }
    }

    /**
     * Verify Router meta
     *
     * @param element Router taw type
     * @return verify result
     */
    private boolean verify(Element element) {
        Router router = element.getAnnotation(Router.class);
        // It must be implement the interface IInterceptor and marked with annotation Interceptor.
        return null != router && isTypeEqual(((TypeElement) element).getSuperclass(), typeMirror.toString());
    }

    private static boolean isTypeEqual(TypeMirror typeMirror, String otherType) {
        return otherType.equals(typeMirror.toString());
    }
}
